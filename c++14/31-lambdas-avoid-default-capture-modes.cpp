//	VIM SETTINGS: {{{3
//	vim: set tabstop=4 modeline modelines=10 foldmethod=marker:
//	vim: set foldlevel=2 foldcolumn=2:
//	}}}1
#include <iostream>
#include <limits>
#include <vector>
#include <string>
#include <random>
#include <algorithm>
#include <iterator>
using namespace std;
//	{{{2
//	get_vector_randoms(), random_num():
//	{{{
vector<int> get_vector_randoms(int size, int min=0, int max=9) {
//	{{{
	//	values generated are in range [min, max] 
    std::uniform_int_distribution<int> distribution(min, max);
    std::default_random_engine generator;
	vector<int> result(size);
	auto gen = [&distribution,&generator]() { return distribution(generator); };
	std::generate(result.begin(), result.end(), gen);
	return result;
}
//	}}}
//	values generated are in range [min, max]
auto random_num  = [](int min, int max) -> int { 	
	std::srand(unsigned(std::time(nullptr))); 
	return std::rand() % (max+1) - min; 
};
//	}}}
//	Ongoings:
//	{{{
//	Ongoing: 2022-05-07T00:38:49AEST if re-ordering the declarations of Widget member variables min/max and divisor can leave divisor undefined, (does that not imply) there is no best practice for defining member variables (in terms of each other)?
//	Ongoing: 2022-05-07T00:11:13AEST 'random_num', better as a lambda/function (don't tell me 'better as a macro'?)
//	Ongoing: 2022-05-06T23:44:03AEST best practice -> using global/static variables in lambdas?
//	Ongoing: 2022-05-06T23:42:53AEST f_ii is even worse(?) (elaborate)
//	Ongoing: 2022-05-06T23:41:26AEST 'random_num' (does '-> int' make a difference?) 
//	Ongoing: 2022-05-03T21:53:00AEST is 'avoid default capture modes' applicable to function pointers (anything other than lambdas?) -> (if only relavent to lambdas, add 'lambda' to filename (before commiting)) [...] -> (having added it, (is the question still <valid/meaningful?>))
//	Ongoing: 2022-05-07T00:12:19AEST implicit use of 'this' pointer (this capture) -> by-value vs by-reference [...] difference between capturing 'this' by-value/reference
//	Ongoing: 2022-05-06T23:48:12AEST 'WorkWithContainer' example with 'sum' (or something more likely to give a result that isn't 'false') instead of 'all_of' [...] -> sum of divisions/modulus?
//	Ongoing: 2022-08-16T00:49:44AEST Verify 'this' capture behaviour of [=] (equivalent to [=, this]?) (differences for C++14/C++17/C++20? -> is [=] the same (vis-a-vis this/*this for all C++ versions?)
//	}}}
//	TODO: 2022-05-07T00:36:24AEST Examples use of 'AddDivisorFilter' / 'Widget::addFilter' (featuring) undefined behaviour

//	Lambda terminology:
//			lambda expression: the code (expression) declaring a lambda
//			closure class: class generated by compiler from each lambda, from which closures are instantiated
//			closure: runtime object created by lambda (including copies/references to captured data)

//	<C++11> has two default capture modes
//			[=]		by-value
//			[&]		by-reference

//	Book contention: both these are bad.
//	Default by-reference capture can lead to dangling references, as does default by-value capture (with the added danger of the false sense of security of by-value, and making one think one's closures are self contained when they may not be). Explicitly listing the values one is capturing, (whether by value or reference), makes mistakes due to dangling variables less likely.


//	Example: dangling references using default by-reference capture
//	'roll' is a local variable captured by reference, when function returns, roll will dangle
using FilterContainer = vector<std::function<bool(int)>>;
void AddDivisorFilter(FilterContainer& filters) {
	srand(time(0));
	int min = 1, max = 10;
	int roll = min + rand() % (max - min + 1);
	//	Ongoing: 2022-05-06T23:11:37AEST (how?) do dangling references cause things to go boom?
	auto f = [&](int x) { return x % roll == 0; };
	filters.emplace_back(f);
}
//	'roll' goes out of scope, new lambda in 'filters' now has a dangling reference


//	Example: while a lambda using default by-reference capture can be used safely in some contexts, (this is still bad practice), as this makes it possible to later move it to another context where the same by-reference captures are no longer safe
template<typename C>
bool WorkWithContainer(C& container) {
	using std::begin;			//	for genericity (see item 13)
	using std::end;
	int min = 1, max = 10;
	int roll = random_num(min, max);
	auto f = [&](int x) { return x % roll == 0; };
	return std::all_of(begin(container), end(container), f);
}
//	'f' is safe in this context, because we never use it outside the scope it is declared in 


//	Example: a pointer captured by-value may be deleted before it is used
void Example_deleted_captured_pointer() {
	int* x = new int(53);
	auto f_i = [x]() { return *x; };
	auto f_ii = [=]() { return *x; };
	delete x;
	//	error, value at pointer 'x' has been deleted
	//f_i(5);		//	undefined
	//f_ii(5);		//	undefined
	(void) f_i; (void) f_ii;
}


//	Example: capture of 'this' pointer
//	Every non-static member function has an implicit 'this' pointer.
//	<(Capture (by-value, or both) only applies to non-static local variables (including parameters) visible in the scope where the lambda is created (that is, not class member variables))>
class Widget {
	//	min/max must be declared before 'divisor' as they are used to initalize it
	int min = 1, max = 10;
	int divisor;
public:
	Widget() : divisor(random_num(min, max)) {
		cout << "divisor=(" << divisor << ")\n";
	}
	void addFilter(FilterContainer& filters) const {

		//	capture 'this' by-reference, points to current object
		auto f_xi = [this](int x) { return x % divisor == 0; };

		//	<C++17> capture 'this' by-value, makes a copy of current object 
		auto f_x = [*this](int x) { return x % divisor == 0; };

		//	[&] is equivalent to [&, this]
		auto f = [&](int x) { return x % divisor == 0; };

		//	[=] is equivalent to [=, this]
		auto f_iii = [=](int x) { return x % divisor == 0; };
		//	[=, this] requires <C++20>
		//	[=, *this] requires <C++17>
		//	<(what does C++20 deprecate? 'The implicit capture of *this when the capture default is = is deprecated')>

		//	error: 'this' is not accessible unless captured
		//auto f_viii = [](int x) { return x % this->divisor == 0; }

		//	error: cannot access non-local 'divisor' without 'this' capture
		//auto f_ii = [](int x) { return x % divisor == 0; };	

		//	error: no local variable 'divisor' to be captured
		//auto f_iv = [divisor](int x) { return x % divisor == 0; };

		//	error: <invalid> <(cannot use '->' in lambda capture)>
		//auto f_vii = [this->divisor](int x) { return x % divisor == 0; };

		//	capture member variable by-value
		auto f_v = [divisor = this->divisor](int x) { return x % divisor == 0; };	
		auto f_vi = [divisor = divisor](int x) { return x % divisor == 0; };	

		//	make a copy of 'divisor' and capture that by-value
		auto divisorCopy = divisor;
		auto f_ix = [divisorCopy](int x) { return x % divisorCopy == 0; };

		filters.emplace_back(f);

		(void) f_iii; (void) f_v; (void) f_vi; (void) f_xi; (void) f_ix; (void) f_x;
	}
};
//	If instance of 'Widget' used to add new lambdas to 'filters' goes out of scope, any variables accessed implicitly through 'this' pointer are left dangling.
//	<C++20> deprecates capturing 'this' through [=]


//	Example: default by-value capture can imply static variables are being captured by-value when they are not
void addFilter(FilterContainer& filters) {
	//	static variables are not captured by-value
	static int divisor = 53;

	//	static variable is accessible without capture
	auto f_ii = [](int x) { return x % divisor == 0; };

	//	reader may mistakenly conclude 'divisor' has been captured by value
	auto f_i = [=](int x) { return x % divisor == 0; };

	//	error: cannot capture static variable by-value
	//auto f_iii = [divisor](int x) { return x % divisor == 0; };

	//	capture copy of static variable by-value
	auto f_iv = [divisor=divisor](int x) { return x % divisor == 0; };

	filters.emplace_back(f_i);

	//	incrementing static value will update value used by all previous lambdas
	++divisor;

	(void) f_ii; (void) f_iv;
}


class A {
public:
	int x;
	A(int X) : x(X) {}
	auto get_lambda_defaultByVal() { return [=]() { return this->x; }; }
	auto get_lambda_defaultByRef() { return [&]() { return this->x; }; }
	auto get_lambda_CopyThis() { return [*this]() { return this->x; }; }
};

int main()
{
	vector<int> r1 = get_vector_randoms(1);
	auto result1 = WorkWithContainer(r1);
	cout << "result1=(" << result1 << ")\n";
	cout << "\n";

	Widget w1;
	cout << "\n";

	A a1(53);
	auto f1 = a1.get_lambda_defaultByRef();
	auto f2 = a1.get_lambda_defaultByVal();
	auto f3 = a1.get_lambda_CopyThis();
	a1.x = 9;
	cout << "f1=(" << f1() << "), f2=(" << f2() << "), f3=(" << f3() << ")";
	cout << "\n";

	return 0;
}

//	Summary:
//		Default by-reference capture can lead to dangling references
//		Default by-value capture is susceptible to dangling pointers, and it can misleadingly suggest lambdas are self contained, or that they capture variables they do not (static variables)
//		Member variables are only accessible through 'this', since both default captures capture 'this' (not making a copy of the object), this can incorrectly suggest a member variable has been captured by-value (use '*this' to capture a copy of the object).
//		Although default capture can be used safely in some contexts, best practice is to avoid them due to the danger of later moving a lambda to a context where captured values can no longer be used safely
//		Capturing variables explicitly helps clarifiy how they are used, and helps avoid using captured variables incorrectly.

